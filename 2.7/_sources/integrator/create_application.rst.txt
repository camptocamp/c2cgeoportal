.. _integrator_create_application:

Create a new application
========================

Creating a new c2cgeoportal application is done by applying two Cookiecutter scaffolds
(a.k.a. templates and scaffolds). These scaffolds are provided by the
``c2cgeoportal`` package. So to be able to create a c2cgeoportal application
the ``c2cgeoportal`` package must be installed.

Project structure
-----------------

In the simple case, the root directory of the application is the directory
created by the c2cgeoportal scaffolds (the ``create`` and
``update`` scaffolds).


Set environment variables
-------------------------

For this procedure, we need to set some environment variables:

.. prompt:: bash

   GEOMAPFISH_VERSION=<release>
   GEOMAPFISH_PROJECT=<project>
   GEOMAPFISH_PACKAGE=<package>

Where ``<release>`` can be found on :docker_hub:`Docker Hub <camptocamp/geomapfish-tools>`,
<project> is the project name that should be the GitHub repository name, <package> is the package name.


List existing scaffolds
-----------------------

To list the available scaffolds, use the following command, either
from the root directory of c2cgeoportal (if you have followed the instructions
from the previous section), or from the root directory of the existing
c2cgeoportal application you want to create the new application from:

.. prompt:: bash

    docker run --rm \
        camptocamp/geomapfish-tools:${GEOMAPFISH_VERSION} \
        pcreate -l

You should at least see the c2cgeoportal scaffolds:

* advance_create
* advance_update
* create
* update

Create the new application
--------------------------

To create the application, first apply the ``create`` scaffold:

.. prompt:: bash

    docker run --rm -ti --volume=$(pwd):/src \
        camptocamp/geomapfish-tools:${GEOMAPFISH_VERSION} \
        run $(id -u) $(id -g) /src \
        pcreate --scaffold=create \
        ${GEOMAPFISH_PROJECT}

.. note::

    Do not add any '/' after the project name.

You will be asked to enter the SRID and the Apache vhost for this project. Note
that the default extent would be defined directly from the SRID. You can change
it later.

.. note::

    You can define this information directly in the command line using
    parameters:

     .. prompt:: bash

        docker run --rm -ti --volume=$(pwd):/src \
            --env=SRID=2056 \
            --env=EXTENT="2420000,1030000,2900000,1350000" \
            camptocamp/geomapfish-tools:${GEOMAPFISH_VERSION} \
            run $(id -u) $(id -g) /src \
            pcreate --scaffold=create \
            --package-name=${GEOMAPFISH_PACKAGE} \
            ${GEOMAPFISH_PROJECT}

This will create a directory named ``<project>`` in you current directory.


For an advance application, apply the ``advance_create`` scaffold:

.. prompt:: bash

    docker run --rm -ti --volume=$(pwd):/src \
        camptocamp/geomapfish-tools:${GEOMAPFISH_VERSION} \
        run $(id -u) $(id -g) /src \
        pcreate --scaffold=advance_create \
        ${GEOMAPFISH_PROJECT} --overwrite


Now apply the ``update`` scaffold:

.. prompt:: bash

    docker run --rm -ti --volume=$(pwd):/src \
        camptocamp/geomapfish-tools:${GEOMAPFISH_VERSION} \
        run $(id -u) $(id -g) /src \
        pcreate --scaffold=update \
        ${GEOMAPFISH_PROJECT} --overwrite

.. note::

    Do not add any '/' after the project name.

The ``update`` scaffold is also used to update the
application. The files generated by this scaffold are prefixed with
``CONST_``, which means they are *constant* files that should not be changed.
Following this rule is important for easier updates.


For an advance application apply the ``advance_update`` scaffold:

.. prompt:: bash

    docker run --rm -ti --volume=$(pwd):/src \
        camptocamp/geomapfish-tools:${GEOMAPFISH_VERSION} \
        run $(id -u) $(id -g) /src \
        pcreate -s advance_update ${GEOMAPFISH_PROJECT}


Go to your new project:

.. prompt:: bash

    cd ${GEOMAPFISH_PROJECT}

For advance application you also should:

Add an attribute ``advance: true`` in your ``project.yaml`` file.

In the ``docker-compose.yaml`` file in the service ``geoportal`` you should replace
 ``service: geoportal`` by ``service: geoportal-advance``, and in service ``alembic`` you should replace
 ``service: alembic`` by ``service: alembic-advance``.

Simple application
------------------

In contrast, a full application is an application for which the all possibilities for customization are
made available, a simple application is an application for which no custom code is needed
(Python or JavaScript).

See also :ref:`integrator_structure` for more information.

The documentation sections, in administrator and integrator guides, indicate whether the current
section applies to the simple application mode or not.


To convert an application to a simple application you should do:

.. prompt:: bash

    git rm geoportal
    git checkout geoportal/vars.yaml
    git checkout geoportal/CONST_vars.yaml
    git checkout geoportal/CONST_config-schema.yaml
    git checkout geoportal/<project>_geoportal/locale/
    git checkout geoportal/<project>_geoportal/static/
    git rm CONST_create_template/geoportal
    git checkout CONST_create_template/geoportal/vars.yaml
    git checkout CONST_create_template/geoportal/CONST_vars.yaml
    git checkout CONST_create_template/geoportal/CONST_config-schema.yaml
    git checkout CONST_create_template/geoportal/<project>_geoportal/locale/
    git checkout CONST_create_template/geoportal/<project>_geoportal/static/

You should also set an API name, in the ``vars.yaml`` file, in `vars/api/name`` and also modify the
``geoportal/<package>_geoportal/static/apihelp/index.html`` file.

Remove the attribute ``advance: true`` in your ``project.yaml`` file.

Put the application under revision control
------------------------------------------

Now is a good time to put the application source code under revision control.

To add a project in a new repository
....................................

Add the project:

.. prompt:: bash

    git init
    git remote add origin git@github.com:camptocamp/${GEOMAPFISH_PROJECT}.git

Commit and push on the main repository:

.. prompt:: bash

    git add .
    git commit -m "Initial commit"
    git push origin master

Configuration of different environments in your project
-------------------------------------------------------

Concepts
........

Application instances for different environments or for personal development should be configured through
environment variables that are defined in the ``env`` files (file with default value: ``env.default``,
file with project values: ``env.project``). Each environment can have its own ``env`` file (for example,
development, integration, production).

Whenever possible, it is strongly advised not to extend the ``vars.yaml`` file.
We recommend instead that you use dynamic variables as described below.
However, in some use cases extending ``vars.yaml`` may be needed:

* Configuring highly specific environments
* Configuration of a multi-organization project

Use of dynamic variables
........................

Variables used in the application configuration files (files ``vars.yaml``)
can be made dynamic by means of environment variable. For this, in the main file
``vars.yaml``, add a block ``runtime_environment`` at the bottom of the file.

In this same file, you can change the value of a parameter by putting it in
uppercase (example: ``host: '{HOST}'``). This parameter must be listed in the
interpreted parameters section:

.. code:: yaml

    extends: CONST_vars.yaml

    vars:
        host: '{HOST}'
    ...
    runtime_environment:
        - HOST

In the ``env.project`` file, add parameters you want to change as exported variables:

.. code::

    HOST=domaine.different.com

In the ``env`` file that extends this main file, you only need to define the environment variables:

.. code::

   HOST=prod.different.com

Configure the application
-------------------------

As the integrator, you need to edit the ``vars.yaml`` and ``env.project`` files to configure the application.

Do not forget to add your changes to git:

.. prompt:: bash

    git add vars.yaml env.project
    git commit -m "Configure the project"
    git push origin master

.. note::

    If you are using a multi-organization project, you should add all new children to
    the parent site check_collector configuration.

After creation and minimal setup the application is ready to be installed.
Then follow the sections in the install application guide:

* :ref:`integrator_install_application_setup_database`.
* :ref:`integrator_install_application_create_schema`.
* :ref:`integrator_install_application_install_application`.

.. note::

   If you want a default theme, you can run:

   .. prompt:: bash

      docker-compose exec geoportal create-demo-theme


Dynamic configuration
---------------------

Several files are generated on runtime, their content depending on the variables you
have set as environment variables.

The files can have the extension ``.tmpl`` and it use bash syntax (``${VARIABLE}``).

GitHub workflows
----------------

With the application we have some predefined workflows.

`.github/workflows/main.yaml`
.............................

The workflow that will run on all your commits, it will:
- Run some code style checks on your code.
- Build you application.
- Run the acceptance tests (if configured).
- Publish the application on DockerHub.
- Trigger another workflow (on ArgoCD repository) to deploy you new application.

`.github/workflows/rebuild.yaml`
................................

This workflow run on each night to rebuild the application with the new version of the base images.

Be careful, GitHub will read only the file present on the main branch.

`.github/workflows/update_l10n.yaml`
....................................

This workflow will query the `locale.pot` view, using `PROJECT_PUBLIC_URL` found in `Makefile`,
and open a pull request to update the localization files (`.po`) with current list of translatable strings.

Be careful, GitHub will read only the file present on the main branch.

Acceptance tests
................

To have some acceptance tests you need to have a minimal dump of your database in the repository,
it can be obtained with:

.. prompt:: bash

    scripts/db-backup --arg=--schema=<schema> ../dump.backup

In the `Makefile` you should add something like:

```
DUMP_FILE=dump.backup

.PHONY: acceptance-init
acceptance-init: ## Initialize the acceptance tests
    docker-compose --file=docker-compose.yaml --file=docker-compose-db.yaml up -d
    docker-compose exec -T geoportal wait-db
    docker-compose exec -T tools psql --command="DROP EXTENSION IF EXISTS postgis CASCADE"
    scripts/db-restore --docker-compose-file=docker-compose.yaml --docker-compose-file=docker-compose-db.yaml \
        --arg=--clean --arg=--if-exists --arg=--verbose $(DUMP_FILE)

.PHONY: acceptance
acceptance: ## Run the acceptance tests
    docker-compose exec -T tools pytest -vv tests/
```

In the file `.github/workflows/main.yaml` you should add something like:

```yaml
      - name: Initialize the acceptance tests
        run: make acceptance-init
      - run: c2cciutils-docker-logs
        if: always()

      - name: Run the acceptance tests
        run: make acceptance
      - run: c2cciutils-docker-logs
        if: always()

```

You should add a `docker-compose-db.yaml` file, with:

```
# This file is used by the acceptance tests to have a local database.

version: '2.3'

volumes:
  postgresql_data:

services:
  config: &db-config
    environment:
      - PGHOST=db
      - PGHOST_SLAVE=db
      - PGSSLMODE=prefer
  geoportal: *db-config
  # geoportal-advance: *db-config
  tools: *db-config
  alembic: *db-config
  # alembic-advance: *db-config
  # webpack_dev_server: *db-config

  db:
    extends:
      file: docker-compose-lib.yaml
      service: db
    volumes:
      - postgresql_data:/var/lib/postgresql/data
```

And finally the file with the tests `tests/test_app.py` with:

```
import time
from typing import Dict

import pytest
import requests


@pytest.mark.parametrize(
    "url,params",
    [
        ("https://front", {}),
        ("https://front/themes", {}),
        ("https://front/static-geomapfish/0/locales/fr.json", {}),
        ("https://front/dynamic.json", {"interface": "desktop"}),
        ("https://front/dynamic.json", {"interface": "desktop", "query": "", "path": "/"}),
        ("https://front/c2c/health_check", {}),
        ("https://front/c2c/health_check", {"max_level": "1"}),
        ("https://front/c2c/health_check", {"checker": "check_collector"}),
        ("https://front/admin/layertree", {}),
        ("https://front/admin/layertree/children", {}),
        ("http://mapserver:8080/mapserv_proxy", {"SERVICE": "WMS", "REQUEST": "GetCapabilities"}),
        (
            "https://front/mapserv_proxy",
            {"ogcserver": "source for image/png", "SERVICE": "WMS", "REQUEST": "GetCapabilities"},
        ),
    ],
)
def test_url(url: str, params: Dict[str, str]) -> None:
    """Tests that some URL didn't return an error."""
    for _ in range(60):
        response = requests.get(url, params=params, verify=False, timeout=240)  # nosec
        if response.status_code == 503:
            time.sleep(1)
            continue
        break
    assert response.status_code == 200, response.text


def test_admin() -> None:
    """Tests that the admin page will provide the login page."""
    response = requests.get("https://front/admin/", verify=False, timeout=240)  # nosec
    assert response.status_code == 200, response.text
    assert "Login" in response.text
```
