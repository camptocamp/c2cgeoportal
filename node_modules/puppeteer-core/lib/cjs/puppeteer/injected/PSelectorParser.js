"use strict";
/**
 * Copyright 2023 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _TokenSpan_tokens, _TokenSpan_selector;
Object.defineProperty(exports, "__esModule", { value: true });
exports.parsePSelectors = void 0;
const PSelectorTokenizer_js_1 = require("./PSelectorTokenizer.js");
class TokenSpan {
    constructor(selector) {
        _TokenSpan_tokens.set(this, []);
        _TokenSpan_selector.set(this, void 0);
        __classPrivateFieldSet(this, _TokenSpan_selector, selector, "f");
    }
    get length() {
        return __classPrivateFieldGet(this, _TokenSpan_tokens, "f").length;
    }
    add(token) {
        __classPrivateFieldGet(this, _TokenSpan_tokens, "f").push(token);
    }
    toStringAndClear() {
        const startToken = __classPrivateFieldGet(this, _TokenSpan_tokens, "f")[0];
        const endToken = __classPrivateFieldGet(this, _TokenSpan_tokens, "f")[__classPrivateFieldGet(this, _TokenSpan_tokens, "f").length - 1];
        __classPrivateFieldGet(this, _TokenSpan_tokens, "f").splice(0);
        return __classPrivateFieldGet(this, _TokenSpan_selector, "f").slice(startToken.pos[0], endToken.pos[1]);
    }
}
_TokenSpan_tokens = new WeakMap(), _TokenSpan_selector = new WeakMap();
const ESCAPE_REGEXP = /\\[\s\S]/g;
const unquote = (text) => {
    if (text.length > 1) {
        for (const char of ['"', "'"]) {
            if (!text.startsWith(char) || !text.endsWith(char)) {
                continue;
            }
            return text
                .slice(char.length, -char.length)
                .replace(ESCAPE_REGEXP, match => {
                return match.slice(1);
            });
        }
    }
    return text;
};
function parsePSelectors(selector) {
    var _a;
    let isPureCSS = true;
    const tokens = (0, PSelectorTokenizer_js_1.tokenize)(selector);
    if (tokens.length === 0) {
        return [[], isPureCSS];
    }
    let compoundSelector = [];
    let complexSelector = [compoundSelector];
    const selectors = [complexSelector];
    const storage = new TokenSpan(selector);
    for (const token of tokens) {
        switch (token.type) {
            case "combinator" /* TokenType.Combinator */:
                switch (token.content) {
                    case ">>>" /* PCombinator.Descendent */:
                        isPureCSS = false;
                        if (storage.length) {
                            compoundSelector.push(storage.toStringAndClear());
                        }
                        compoundSelector = [];
                        complexSelector.push(">>>" /* PCombinator.Descendent */);
                        complexSelector.push(compoundSelector);
                        continue;
                    case ">>>>" /* PCombinator.Child */:
                        isPureCSS = false;
                        if (storage.length) {
                            compoundSelector.push(storage.toStringAndClear());
                        }
                        compoundSelector = [];
                        complexSelector.push(">>>>" /* PCombinator.Child */);
                        complexSelector.push(compoundSelector);
                        continue;
                }
                break;
            case "pseudo-element" /* TokenType.PseudoElement */:
                if (!token.name.startsWith('-p-')) {
                    break;
                }
                isPureCSS = false;
                if (storage.length) {
                    compoundSelector.push(storage.toStringAndClear());
                }
                compoundSelector.push({
                    name: token.name.slice(3),
                    value: unquote((_a = token.argument) !== null && _a !== void 0 ? _a : ''),
                });
                continue;
            case "comma" /* TokenType.Comma */:
                if (storage.length) {
                    compoundSelector.push(storage.toStringAndClear());
                }
                compoundSelector = [];
                complexSelector = [compoundSelector];
                selectors.push(complexSelector);
                continue;
        }
        storage.add(token);
    }
    if (storage.length) {
        compoundSelector.push(storage.toStringAndClear());
    }
    return [selectors, isPureCSS];
}
exports.parsePSelectors = parsePSelectors;
//# sourceMappingURL=PSelectorParser.js.map