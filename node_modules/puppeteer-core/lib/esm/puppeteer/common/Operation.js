/**
 * Copyright 2023 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var _Operation_instances, _Operation_settled, _Operation_effects, _Operation_error, _Operation_effectsPromise_get;
/**
 * Operations are promises that can have <a
 * href="https://en.wikipedia.org/wiki/Side_effect_(computer_science)">effects</a>
 * added on them (through {@link Operation.effect}).
 *
 * Semantically-speaking, adding an effect equates to guaranteeing the operation
 * causes the added effect.
 *
 * The first effect that errors will propogate its error back to the operation.
 *
 * @example
 *
 * ```ts
 * await input.click().effect(async () => {
 *   await page.waitForNavigation();
 * });
 * ```
 *
 * @remarks
 *
 * Adding effects to a completed operation will result in an error. This occurs
 * when either
 *
 * 1. the effects are added asynchronously or
 * 2. the operation was awaited before effects were added.
 *
 * For example for (1),
 *
 * ```ts
 * const operation = input.click();
 * await new Promise(resolve => setTimeout(resolve, 100));
 * await operation.effect(() => console.log('Works!')); // This will throw because of (1).
 * ```
 *
 * For example for (2),
 *
 * ```ts
 * const operation = await input.click();
 * await operation.effect(() => console.log('Works!')); // This will throw because of (2).
 * ```
 *
 * Tl;dr, effects **must** be added synchronously (no `await` statements between
 * the time the operation is created and the effect is added).
 *
 * @internal
 */
export class Operation extends Promise {
    constructor() {
        super(...arguments);
        _Operation_instances.add(this);
        _Operation_settled.set(this, false);
        _Operation_effects.set(this, []);
        _Operation_error.set(this, void 0);
    }
    /**
     * @internal
     */
    static create(fn, delay = 0) {
        return new Operation((resolve, reject) => {
            setTimeout(async () => {
                try {
                    resolve(await fn());
                }
                catch (error) {
                    reject(error);
                }
            }, delay);
        });
    }
    /**
     * Adds the given effect.
     *
     * @example
     *
     * ```ts
     * await input.click().effect(async () => {
     *   await page.waitForNavigation();
     * });
     * ```
     *
     * @param effect - The effect to add.
     * @returns `this` for chaining.
     *
     * @public
     */
    effect(effect) {
        if (__classPrivateFieldGet(this, _Operation_settled, "f")) {
            throw new Error('Attempted to add effect to a completed operation. Make sure effects are added synchronously after the operation is created.');
        }
        __classPrivateFieldGet(this, _Operation_effects, "f").push((async () => {
            try {
                return await effect();
            }
            catch (error) {
                // Note we can't just push a rejected promise to #effects. This is because
                // all rejections must be handled somewhere up in the call stack and since
                // this function is synchronous, it is not handled anywhere in the call
                // stack.
                __classPrivateFieldSet(this, _Operation_error, error, "f");
            }
        })());
        return this;
    }
    then(onfulfilled, onrejected) {
        return super.then(value => {
            __classPrivateFieldSet(this, _Operation_settled, true, "f");
            return __classPrivateFieldGet(this, _Operation_instances, "a", _Operation_effectsPromise_get).then(() => {
                if (!onfulfilled) {
                    return value;
                }
                return onfulfilled(value);
            }, onrejected);
        }, reason => {
            __classPrivateFieldSet(this, _Operation_settled, true, "f");
            if (!onrejected) {
                throw reason;
            }
            return onrejected(reason);
        });
    }
}
_Operation_settled = new WeakMap(), _Operation_effects = new WeakMap(), _Operation_error = new WeakMap(), _Operation_instances = new WeakSet(), _Operation_effectsPromise_get = function _Operation_effectsPromise_get() {
    if (__classPrivateFieldGet(this, _Operation_error, "f")) {
        return Promise.reject(__classPrivateFieldGet(this, _Operation_error, "f"));
    }
    return Promise.all(__classPrivateFieldGet(this, _Operation_effects, "f"));
};
//# sourceMappingURL=Operation.js.map